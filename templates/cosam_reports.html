{% extends 'base.html' %}

{% block title %}COSAM - Reportes{% endblock %}

{% block content %}
  <section class="entries">
    <header class="entries-header">
      <div>
        <h2>Reportes COSAM</h2>
        <p>Resumen de fichas derivadas al COSAM, con filtros y visualización dinámica.</p>
      </div>
    </header>

    <form method="get" class="formulario" style="margin-bottom: 1.5rem;">
      <section>
        <h3>Filtros</h3>
        <div class="field-grid">
          <label>
            <span>Fecha desde</span>
            <input type="date" name="desde" value="{{ filtros.desde }}">
          </label>
          <label>
            <span>Fecha hasta</span>
            <input type="date" name="hasta" value="{{ filtros.hasta }}">
          </label>
          <div id="metric-selects"
               class="metric-selects"
               data-options='{{ metric_options | tojson }}'
               data-selected='{{ metric_keys | tojson }}'>
          </div>
          <!-- El tipo de gráfico se controla fuera de los filtros de datos -->
        </div>
      </section>
      <div class="actions" style="margin-top: 1rem;">
        <button type="submit" class="primary">Aplicar filtros</button>
      </div>
    </form>

    {% if totales.total > 0 %}
      <section class="summary-section report-chart-section">
        <div class="report-chart-header">
          <h3>Visualización</h3>
          <label class="chart-type-select">
            <span>Tipo de gráfico</span>
            <select id="chart-type-select">
              <option value="bar" {% if chart_type == 'bar' %}selected{% endif %}>Barras</option>
              <option value="line" {% if chart_type == 'line' %}selected{% endif %}>Líneas</option>
              <option value="pie" {% if chart_type == 'pie' %}selected{% endif %}>Pie</option>
            </select>
          </label>
        </div>
        <div class="report-chart-wrapper">
          <canvas id="chart-main" height="260"></canvas>
        </div>
      </section>

      <section class="summary-section">
        <h3>Detalle segun filtros seleccionados</h3>
        {% if detail_table and detail_table["rows"] %}
          {% if detail_table.mode == 'grouped' %}
            <table class="entries-table">
              <thead>
                <tr>
                  <th>{{ detail_table.row_header }}</th>
                  {% for head in detail_table.column_headers %}
                    <th>{{ head }}</th>
                  {% endfor %}
                  <th>Total</th>
                </tr>
              </thead>
              <tbody>
                {% for row in detail_table["rows"] %}
                  <tr>
                    <td>{{ row["label"] }}</td>
                    {% for val in row["values"] %}
                      <td>{{ val }}</td>
                    {% endfor %}
                    <td>{{ row["total"] }}</td>
                  </tr>
                {% endfor %}
              </tbody>
              <tfoot>
                <tr>
                  <th>Total</th>
                  {% for total in detail_table.column_totals %}
                    <th>{{ total }}</th>
                  {% endfor %}
                  <th>{{ detail_table.grand_total }}</th>
                </tr>
              </tfoot>
            </table>
          {% elif detail_table.mode == 'timeline' %}
            <table class="entries-table">
              <thead>
                <tr>
                  <th>{{ detail_table.row_header }}</th>
                  {% for col in detail_table.columns %}
                    <th>{{ col }}</th>
                  {% endfor %}
                  <th>Total</th>
                </tr>
              </thead>
              <tbody>
                {% for row in detail_table["rows"] %}
                  <tr>
                    <td>{{ row["label"] }}</td>
                    {% for val in row["values"] %}
                      <td>{{ val }}</td>
                    {% endfor %}
                    <td>{{ row["total"] }}</td>
                  </tr>
                {% endfor %}
              </tbody>
              <tfoot>
                <tr>
                  <th>Total</th>
                  {% for total in detail_table.column_totals %}
                    <th>{{ total }}</th>
                  {% endfor %}
                  <th>{{ detail_table.grand_total }}</th>
                </tr>
              </tfoot>
            </table>
          {% else %}
            <table class="entries-table">
              <thead>
                <tr>
                  <th>{{ detail_table.axis_label }}</th>
                  <th>Casos</th>
                  <th>% del total</th>
                </tr>
              </thead>
              <tbody>
                {% for row in detail_table["rows"] %}
                  <tr>
                    <td>{{ row["label"] }}</td>
                    <td>{{ row["value"] }}</td>
                    <td>{{ '%.1f' | format(row["pct"]) }}%</td>
                  </tr>
                {% endfor %}
              </tbody>
              <tfoot>
                <tr>
                  <th>Total</th>
                  <th>{{ detail_table.grand_total }}</th>
                  <th>100%</th>
                </tr>
              </tfoot>
            </table>
          {% endif %}
        {% else %}
          <p class="empty-state">No hay datos para mostrar con los filtros actuales.</p>
        {% endif %}
      </section>
      <section class="summary-section" style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; justify-content: flex-end;">
        <div class="inline-form" style="display: inline-flex; gap: 0.5rem;">
          <form method="post" action="{{ url_for('cosam_reportes') }}" class="inline-form">
            <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
            <input type="hidden" name="action" value="add">
            <input type="hidden" name="desde" value="{{ filtros.desde }}">
            <input type="hidden" name="hasta" value="{{ filtros.hasta }}">
            <input type="hidden" name="chart_type" value="{{ chart_type }}">
            <input type="hidden" name="metric" value="{{ metric_keys[0] if metric_keys|length > 0 else '' }}">
            <input type="hidden" name="metric2" value="{{ metric_keys[1] if metric_keys|length > 1 else '' }}">
            <input type="hidden" name="metric3" value="{{ metric_keys[2] if metric_keys|length > 2 else '' }}">
            <button type="submit" class="secondary" style="background: #fff; color: #1d4ed8; border: 1px solid #1d4ed8; border-radius: 999px; padding: 0.55rem 1.4rem; font-weight: 600;">Sumar información</button>
          </form>
          <form method="post" action="{{ url_for('cosam_reportes') }}" class="inline-form">
            <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
            <input type="hidden" name="action" value="clear">
            <button type="submit" class="secondary" style="background: #fff; color: #1d4ed8; border: 1px solid #1d4ed8; border-radius: 999px; padding: 0.55rem 1.4rem; font-weight: 600;">Limpiar guardados</button>
          </form>
        </div>
        <form method="post" action="{{ url_for('cosam_reportes') }}" class="inline-form">
          <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
          <input type="hidden" name="action" value="generate">
          <input type="hidden" name="desde" value="{{ filtros.desde }}">
          <input type="hidden" name="hasta" value="{{ filtros.hasta }}">
          <input type="hidden" name="chart_type" value="{{ chart_type }}">
          <input type="hidden" name="metric" value="{{ metric_keys[0] if metric_keys|length > 0 else '' }}">
          <input type="hidden" name="metric2" value="{{ metric_keys[1] if metric_keys|length > 1 else '' }}">
          <input type="hidden" name="metric3" value="{{ metric_keys[2] if metric_keys|length > 2 else '' }}">
          <button type="submit" class="primary" style="border-radius: 999px; padding: 0.55rem 1.4rem; font-weight: 600;">Generar informe</button>
        </form>
      </section>

      {% if saved_reports %}
        <section class="summary-section">
          <h3>Información guardada</h3>
          <ul>
            {% for item in saved_reports %}
              <li>
                {{ loop.index }}. {{ item.chart_type|capitalize }} - {{ item.focus }}
                ({{ item.params.desde or 'Todas' }} / {{ item.params.hasta or 'Todas' }})
              </li>
            {% endfor %}
          </ul>
        </section>
      {% endif %}
    {% endif %}
  </section>

  <script src="{{ url_for('static', filename='js/chart.umd.min.js') }}"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
    const chartType = {{ chart_type | tojson }};
    const labels = {{ current["labels"] | tojson }};
    const values = {{ current["values"] | tojson }};
    const title = {{ current["title"] | tojson }} || 'Casos';
    const datasetsRaw = {{ current["datasets"] | tojson }};

    const buildPalette = (n) => {
      const base = ['#2563eb', '#16a34a', '#f97316', '#dc2626', '#7c3aed', '#0d9488', '#eab308', '#ec4899', '#0891b2', '#4b5563'];
      const colors = [];
      for (let i = 0; i < n; i += 1) {
        colors.push(base[i % base.length]);
      }
      return colors;
    };

    const hexToRgba = (hex, alpha = 0.85) => {
      const clean = hex.replace('#', '');
      const bigint = parseInt(clean, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    const ctx = document.getElementById('chart-main');
    if (ctx && labels.length) {
      const kind = ['bar', 'line', 'pie'].includes(chartType) ? chartType : 'bar';
      const palette = buildPalette(Math.max(labels.length, datasetsRaw.length || 1));
      const baseDatasets = (datasetsRaw && datasetsRaw.length)
        ? datasetsRaw
        : [{ label: title, data: values }];
      const datasets = baseDatasets.map((ds, idx) => {
        const color = palette[idx % palette.length];
        const dataset = {
          label: ds.label || `${title} (${idx + 1})`,
          data: ds.data || [],
        };
        if (kind === 'pie') {
          const slices = buildPalette(dataset.data.length || labels.length);
          dataset.backgroundColor = slices;
          dataset.borderColor = slices;
          dataset.borderWidth = 1;
        } else if (kind === 'line') {
          dataset.borderColor = color;
          dataset.backgroundColor = hexToRgba(color, 0.15);
          dataset.pointBackgroundColor = color;
          dataset.tension = 0.25;
          dataset.fill = false;
        } else {
          dataset.backgroundColor = hexToRgba(color, 0.8);
          dataset.borderColor = color;
          dataset.borderWidth = 1;
        }
        return dataset;
      });
      const config = {
        type: kind,
        data: { labels, datasets },
        options: {
          responsive: true,
          plugins: {
            legend: { position: kind === 'pie' ? 'bottom' : 'top' },
            title: { display: true, text: title },
          },
        },
      };
      if (kind !== 'pie') {
        config.options.scales = { y: { beginAtZero: true, ticks: { precision: 0 } } };
      }
      new Chart(ctx, config);
    }

    const refreshSingleParam = (param, value) => {
      const url = new URL(window.location.href);
      if (value) {
        url.searchParams.set(param, value);
      } else {
        url.searchParams.delete(param);
      }
      window.location.href = url.toString();
    };

    const typeSelect = document.getElementById('chart-type-select');
    const metricContainer = document.getElementById('metric-selects');

    const getLimitForType = (kind) => {
      if (kind === 'pie' || kind === 'line') return 1;
      if (kind === 'bar') return 2;
      return 3;
    };

    const options = metricContainer ? JSON.parse(metricContainer.dataset.options || '{}') : {};
    const selectedInit = metricContainer ? JSON.parse(metricContainer.dataset.selected || '[]') : [];

    const renderMetricSelects = (limit) => {
      if (!metricContainer) return;
      metricContainer.innerHTML = '';
      const used = [];

      const addSelect = (index, currentValue) => {
        const wrapper = document.createElement('label');
        wrapper.className = 'metric-select';
        const span = document.createElement('span');
        span.textContent = `Filtro ${index + 1}`;
        const select = document.createElement('select');
        select.dataset.metric = '1';
        select.name = index === 0 ? 'metric' : `metric${index + 1}`;
        const empty = document.createElement('option');
        empty.value = '';
        empty.textContent = '--- Seleccione ---';
        select.appendChild(empty);
        Object.entries(options).forEach(([key, label]) => {
          if (used.includes(key) && key !== currentValue) return;
          const opt = document.createElement('option');
          opt.value = key;
          opt.textContent = label;
          select.appendChild(opt);
        });
        if (currentValue && !used.includes(currentValue)) {
          select.value = currentValue;
          used.push(currentValue);
        }
        wrapper.appendChild(span);
        wrapper.appendChild(select);
        metricContainer.appendChild(wrapper);
        select.addEventListener('change', applyMetricSelection);
      };

      for (let i = 0; i < limit; i += 1) {
        addSelect(i, selectedInit[i] || '');
      }
    };

    const applyMetricSelection = () => {
      const url = new URL(window.location.href);
      const limit = getLimitForType(typeSelect ? typeSelect.value : chartType);
      const params = ['metric', 'metric2', 'metric3'];
      params.forEach((param) => url.searchParams.delete(param));
      const selects = metricContainer ? metricContainer.querySelectorAll('select[data-metric]') : [];
      selects.forEach((sel, idx) => {
        if (idx >= limit) return;
        if (sel.value) {
          const name = idx === 0 ? 'metric' : `metric${idx + 1}`;
          url.searchParams.set(name, sel.value);
        }
      });
      window.location.href = url.toString();
    };

    const updateUIForType = (typeValue) => {
      const limit = getLimitForType(typeValue);
      renderMetricSelects(limit);
    };

    if (typeSelect) {
      updateUIForType(typeSelect.value);
      typeSelect.addEventListener('change', () => {
        updateUIForType(typeSelect.value);
        refreshSingleParam('chart_type', typeSelect.value);
      });
    } else if (metricContainer) {
      updateUIForType(chartType);
    }
  });
</script>


{% endblock %}



